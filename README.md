# Next.js-13version-experience
## SSR, CSR, 그리고 Next.js에서는 어떤 렌더링을 지원할까?
### SSR (Server Side Rendering)

- **정의**
    - 서버 쪽에서 렌더링 준비를 끝마친 상태로 클라이언트에서 전달하는 방식
- **단계**
    1. user가 website 요청을 보냄
    2. 서버는 즉시 렌더링 가능한 html 파일을 만듦
    3. 클라이언트에 전달하여 html은 즉시 렌더링됨. 하지만 javascript가 읽히기 전이라 사이트 조작은 불가능함
    4. 클라이언트가 javascript를 다운받음
    5. javascript 다운 완료 전의 사용자 조작을 기억함
    6. 클라이언트가 javascript 프레임워크를 실행함
    7. javascript 컴파일 후, 기억하고 있던 사용자 조작이 실행되고 웹페이지 상호작용 가능해짐

### CSR (Client Side Rendering)

- **정의**
    - 서버가 요청에 따라 html과 js를 보내주면, 클라이언트 쪽에서 렌더링을 하는 방식
- **단계**
    1. user가 website 요청을 보냄
    2. CDN이 html과 js 접근 링크를 클라이언트로 보냄
    3. 클라이언트가 html를 다운받음 (유저는 그동안 아무것도 볼 수 없음)
    4. 클라이언트가 javascript를 다운받음
    5. js가 실행되면, 데이터를 위한 api가 호출됨 (유저는 placeholder를 봄)
    6. 서버가 api 요청에 응답함
    7. api 요청의 응답으로 받음 데이터를 placeholder 자리에 넣어주고, 웹페이지 상호작용이 가능해짐
    

### SSR vs CSR

- **웹페이지 로딩 시간**
    - 첫 페이지 로딩은 평균적으로 SSR이 더 빠름
        - CSR은 html, css, 모든 스크립트들을 한 번에 불러옴
        - SSR은 필요한 html과 스크립트만 불러옴
    - 나머지 페이지 로딩은 CSR이 더 빠름
        - CSR은 첫 페이지 로딩 시, 나머지 페이지의 코드도 불러왔기 때문에 로딩이 빠름
        - SSR은 나머지 페이지로 라우팅 시, 새로 서버 측에서 불러와야 하기 때문에 더 느림 (첫 페이지 로딩 과정 반복)
- **SEO 대응**
    - CSR은 javascript 실행에 의해 동적으로 컨텐츠가 생성되기 때문에 javascript 실행이 필수적
    - SSR은 서버 사이드에서 컴파일되어 클라이언트로 넘어오기 때문에, 크롤러에 대응하기 용이함
- **서버 자원 사용**
    - SSR은 매번 서버에 요청하기 때문에, 더 많이 사용함
    

### Next.js에서 지원하는 렌더링 방식

- SSG (Static Site Generation)
    - html을 프로젝트 빌드 타임에 생성하고, 각 요청에 따라 재사용함
    - 기본적으로 Next.js 공식 홈페이지에서 추천하는 방식
- SSR
    - 요청이 오면 필요한 html을 생성함
    - 주로 사용자마다 페이지의 데이터가 다르게 보여야 하는 페이지에서 사용됨
    - 매 요청마다 데이터가 자주 업데이트 되는 경우 추천
- CSR
    - 서버에 요청하여 받은 html과 js로 클라이언트 측에서 모두 렌더링
