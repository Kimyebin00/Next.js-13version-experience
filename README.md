# Next.js-13version-experience
## SSR, CSR, 그리고 Next.js에서는 어떤 렌더링을 지원할까?
### SSR (Server Side Rendering)

- **정의**
    - 서버 쪽에서 렌더링 준비를 끝마친 상태로 클라이언트에서 전달하는 방식
- **단계**
    1. user가 website 요청을 보냄
    2. 서버는 즉시 렌더링 가능한 html 파일을 만듦
    3. 클라이언트에 전달하여 html은 즉시 렌더링됨. 하지만 javascript가 읽히기 전이라 사이트 조작은 불가능함
    4. 클라이언트가 javascript를 다운받음
    5. javascript 다운 완료 전의 사용자 조작을 기억함
    6. 클라이언트가 javascript 프레임워크를 실행함
    7. javascript 컴파일 후, 기억하고 있던 사용자 조작이 실행되고 웹페이지 상호작용 가능해짐

### CSR (Client Side Rendering)

- **정의**
    - 서버가 요청에 따라 html과 js를 보내주면, 클라이언트 쪽에서 렌더링을 하는 방식
- **단계**
    1. user가 website 요청을 보냄
    2. CDN이 html과 js 접근 링크를 클라이언트로 보냄
    3. 클라이언트가 html를 다운받음 (유저는 그동안 아무것도 볼 수 없음)
    4. 클라이언트가 javascript를 다운받음
    5. js가 실행되면, 데이터를 위한 api가 호출됨 (유저는 placeholder를 봄)
    6. 서버가 api 요청에 응답함
    7. api 요청의 응답으로 받음 데이터를 placeholder 자리에 넣어주고, 웹페이지 상호작용이 가능해짐
    

### SSR vs CSR

- **웹페이지 로딩 시간**
    - 첫 페이지 로딩은 평균적으로 SSR이 더 빠름
        - CSR은 html, css, 모든 스크립트들을 한 번에 불러옴
        - SSR은 필요한 html과 스크립트만 불러옴
    - 나머지 페이지 로딩은 CSR이 더 빠름
        - CSR은 첫 페이지 로딩 시, 나머지 페이지의 코드도 불러왔기 때문에 로딩이 빠름
        - SSR은 나머지 페이지로 라우팅 시, 새로 서버 측에서 불러와야 하기 때문에 더 느림 (첫 페이지 로딩 과정 반복)
- **SEO 대응**
    - CSR은 javascript 실행에 의해 동적으로 컨텐츠가 생성되기 때문에 javascript 실행이 필수적
    - SSR은 서버 사이드에서 컴파일되어 클라이언트로 넘어오기 때문에, 크롤러에 대응하기 용이함
- **서버 자원 사용**
    - SSR은 매번 서버에 요청하기 때문에, 더 많이 사용함
    

### Next.js에서 지원하는 렌더링 방식

- SSG (Static Site Generation)
    - html을 프로젝트 빌드 타임에 생성하고, 각 요청에 따라 재사용함
    - 기본적으로 Next.js 공식 홈페이지에서 추천하는 방식
- SSR
    - 요청이 오면 필요한 html을 생성함
    - 주로 사용자마다 페이지의 데이터가 다르게 보여야 하는 페이지에서 사용됨
    - 매 요청마다 데이터가 자주 업데이트 되는 경우 추천
- CSR
    - 서버에 요청하여 받은 html과 js로 클라이언트 측에서 모두 렌더링

## Next.js가 13버전으로 업그레이드 하면서 변경된 부분들
### 폴더라우팅 (앱 라우팅)

- **12 버전의 ‘페이지 라우팅’ 방식에서 ‘폴더 라우팅’ 방식으로**
    - 예시) /todo 라우팅
        - 폴더 라우팅 → /app/todo/page.tsx
        - 파일 이름 라우팅 → /pages/todo.tsx
- **Layouts**
    - 리렌더링 방지을 방지하면서 여러 페이지 간에 UI를 쉽게 공유할 수 있음
- **React Server Components**
    - 서버 컴포넌트와 클라이언트 컴포넌트는 각각 서버/클라이언트 중 가장 적합한 일에 사용됨
        
        ⇒ 개발자 경험 향상, 빠르고 인터랙티브한 앱을 단일 프로그래밍 모델로 구축 가능
        
    - 서버 구성요소 사용 ⇒ 초기 페이지 로드 속도 향상
- **Streaming**
    - 렌더링 시, 즉시 로드 상태 및 스트림을 UI 단위로 표시함
    - Server components + 중첩 레이아웃 사용 시
        
        → 부분 즉시 렌더링, 데이터 필요한 부분 로딩 상태 표시
        

### API Routes

- serverless API Endpoint 구축 가능
    - next.js의 자체 서버를 사용해서 다른 서버 필요 없이 api 만들기 가능
        
        ⇒ 백엔드 의존성 줄어듦
        
    - /app/api/route.tsx 에 구축

### Turbopack

- Rust기반 webpack 대체
- vite보다 10배 빠름

### 새로운 Image 컴포넌트 (next/Image)

- 클라이언트 측 JavaScript가 더 적게 포함됨
- alt 태그 필수 → 접근성 개선
- 네이티브 레이지 로딩을 사용하여 성능이 빠름

### 자동 자체 호스팅 폰트 (@next/font)

- 폰트 자동 최적화
- 폰트 파일에 대해 내장 자동 셀프 호스팅 기능 제공
    - css와 폰트 파일은 빌드 시간에 다운됨
    - 브라우저에서 google로 요청 전송 X
- 외부 네트워크 요청 제거 ⇒ 개인 정보 보호 및 성능 향상

### 향상된 Link 컴포넌트 (next/link)

- <Link>는 항상 <a>를 렌더링함

## 왜 요즘 대세는 Next.js일까?
- **SSR이 다시 유행하기 시작함**
    - SSR의 강점
        - 구글 검색 노출이 잘 됨
        - 페이지 로딩 속도가 빠름
        
        ⇒ 수익성이 큼 
        
- **SSR, CSR 선택 사용 가능**
- **리액트 문법을 사용**
    - 리액트를 사용해본 개발자들은 쉽게 입문 가능함
- **개발이 상대적으로 쉬움**
    - 기본 설정이 이미 갖춰져 있어 개발자가 별도로 구성할 필요가 없음
    - 빠르게 프로젝트 시작 가능
